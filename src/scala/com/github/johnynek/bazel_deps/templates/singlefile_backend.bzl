_HEADER = "# DO NOT EDIT: generated by maven_artifact()"
_FETCH_SOURCES_ENV_VAR = "BAZEL_JVM_FETCH_SOURCES"

_JVM_IMPORT_BZL = """
def _jvm_import_impl(ctx):
    if len(ctx.files.jars) != 1:
        fail("Must specify exactly one jar", attr = "jars")
    jar = ctx.files.jars[0]
    compile_jar = ctx.actions.declare_file("%s-stamped.jar" % jar.basename[:-len(".jar")])
    ctx.actions.run(
        inputs = [jar],
        outputs = [compile_jar],
        executable = ctx.executable._singlejar,
        arguments = [
            "--sources", jar.path,
            "--output", compile_jar.path,
            "--deploy_manifest_lines", "Target-Label: %s" % ctx.attr.jar_stamp,
            "--normalize",
            "--exclude_build_data",
        ],
    )
    return [
        DefaultInfo(
            files = depset(direct = [jar]),
        ),
        JavaInfo(
            output_jar = jar,
            compile_jar = compile_jar,
            source_jar = getattr(ctx.file, "srcjar", None),
            deps = [d[JavaInfo] for d in getattr(ctx.attr, "deps", [])],
        ),
    ]

jvm_import = rule(
    _jvm_import_impl,
    attrs = {
        "jars": attr.label_list(allow_files = [".jar"]),
        "deps": attr.label_list(providers = [JavaInfo]),
        "jar_stamp": attr.string(),
        "srcjar": attr.label(allow_single_file = ["-sources.jar"]),
        "_singlejar": attr.label(
            executable = True,
            cfg = "host",
            default = Label("@bazel_tools//tools/jdk:singlejar"),
            allow_files = True,
        ),
    },
)
"""

def _download_artifact(
        ctx,
        sha256,
        classifier = None):
    coord = _decode_maven_coordinates(ctx.attr.artifact)
    classifier = classifier or coord.classifier or ""
    if classifier:
        classifier = "-" + classifier
    group_id = coord.group_id.replace(".", "/")
    version = coord.version
    packaging = coord.packaging
    artifact_id = coord.artifact_id
    final_name = artifact_id + "-" + version + classifier + "." + packaging
    url_suffix = group_id + "/" + artifact_id + "/" + version + "/" + final_name
    urls = []
    for server_url in ctx.attr.repositories:
        if not server_url.endswith("/"):
            urls += [server_url + "/" + url_suffix]
        else:
            urls += [server_url + url_suffix]
    ctx.download(urls, output = final_name, sha256 = sha256)
    return final_name

def _decode_maven_coordinates(artifact, default_packaging = "jar"):
    parts = artifact.split(":")
    group_id = parts[0]
    artifact_id = parts[1]
    version = parts[2]
    classifier = None
    packaging = default_packaging
    if len(parts) == 4:
        packaging = parts[2]
        version = parts[3]
    elif len(parts) == 5:
        packaging = parts[2]
        classifier = parts[3]
        version = parts[4]
    return struct(
        group_id = group_id,
        artifact_id = artifact_id,
        version = version,
        classifier = classifier,
        packaging = packaging,
    )

def _serialize_list(items):
    return "\n        " + "    ".join([
        '"%s",\n    ' % i
        for i in items or []
    ])

def _maven_artifact_impl(ctx):
    # TODO: check inputs are valid (and disjoint where applicable)

    name = ctx.attr.name
    tags = getattr(ctx.attr, "tags", [])

    buildfile_lines = [
        _HEADER,
        'package(default_visibility = ["//visibility:public"])',
    ]
    if ctx.attr.replacement:
        # is it replacement (replacement attr)
        buildfile_lines += ["""
alias(
    name = "{name}",
    actual = "{actual}",
)""".format(
            name = name,
            actual = ctx.attr.replacement,
        )]
    else:
        coord = _decode_maven_coordinates(ctx.attr.artifact)
        if coord.packaging == "pom":
            # is it something to just 'export' (pom packaging, no jars)
            buildfile_lines += ["""
java_library(
    name = "{name}",
    exports = [{exports}],
    tags = [{tags}],
)""".format(
                name = name,
                exports = _serialize_list(ctx.attr.deps),
                tags = _serialize_list(tags),
            )]
        elif coord.packaging == "jar":
            srcjar = None
            if ctx.attr.sha256_src and ctx.os.environ.get(_FETCH_SOURCES_ENV_VAR, "true").lower() == "true":
                srcjar = _download_artifact(ctx, ctx.attr.sha256_src, classifier = "sources")
            jar = _download_artifact(ctx, ctx.attr.sha256)
            ctx.file("jvm_import.bzl", _JVM_IMPORT_BZL)
            buildfile_lines += ["""
load(":jvm_import.bzl", "jvm_import")

jvm_import(
    name = "{name}",
    jars = ["{jar}"],
    srcjar = {srcjar},
    jar_stamp = "{jar_stamp}",
    tags = [{tags}],
    deps = [{deps}],
)""".format(
                name = name,
                jar = jar,
                srcjar = '"%s"' % srcjar if srcjar else "None",
                jar_stamp = ctx.attr.jar_stamp,
                deps = _serialize_list(ctx.attr.deps),
                tags = _serialize_list(tags + [
                    "maven_coordinates=%s" % ctx.attr.artifact,
                ]),
            )]
        else:
            fail("Unsupported packaging '%s' (expected 'pom' or 'jar')" % coord.packaging, attr = "artifact")

    ctx.file("BUILD", "\n".join(buildfile_lines))

    # the coord's packaging is also an alias, to mimic behavior of native.maven_jar
    ctx.file("%s/BUILD" % "jar", "\n".join([
        "",
        """package(default_visibility = ["//visibility:public"])""",
        "",
        "alias(",
        "    name = \"%s\"," % "jar",
        "    actual = \"@%s\"," % name,
        ")",
        "",
    ]))
    return

_maven_artifact = repository_rule(
    _maven_artifact_impl,
    attrs = {
        "replacement": attr.string(),
        "artifact": attr.string(),
        "jar_stamp": attr.string(),
        "deps": attr.string_list(),
        "exports": attr.string_list(),
        "repositories": attr.string_list(doc = "Resolver URLs"),
        "sha256": attr.string(),
        "sha256_src": attr.string(),
    },
    environ = [_FETCH_SOURCES_ENV_VAR],
)

def maven_dependencies(
        # '@repository' (or '//external:targetname') => 'mvn_coord' mapping
        aliases = {}):
    dependencies = _DEPENDENCIES
    m2_repos = _REPOSITORIES.values()

    # print warnings
    missing_alias_coords = {c: None for c in aliases.values() if c not in dependencies}.keys()
    if missing_alias_coords:
        print("\nWARN the following aliases might not work because they're not listed in dependencies:\n  %s" %
              "\n  ".join(sorted(missing_alias_coords)))

    # do aliases, checking if the alias is a <repoName> or a <bind>
    for name, unversioned_coord in aliases.items():
        actual = "@%s" % dependencies[unversioned_coord]["name"]
        if name.startswith("@"):
            name = name[len("@"):]
            _maven_artifact(name = name, replacement = actual)
        elif name.startswith("//external:"):
            name = name[len("//external:"):]
            native.bind(name = name, actual = actual)
        else:
            fail("Bad alias name '%s'. Wanted a bare repository name (eg '@repo_name') or bind target (eg '//external:some/target_name')", attr = "aliases")

    # do dependencies
    for k, kwargs in dependencies.items():
        _maven_artifact(repositories = m2_repos, **kwargs)
    return
