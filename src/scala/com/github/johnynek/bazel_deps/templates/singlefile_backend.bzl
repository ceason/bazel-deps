_HEADER = "# DO NOT EDIT: generated by maven_artifact()"
_FETCH_SOURCES_ENV_VAR = "BAZEL_JVM_FETCH_SOURCES"

_JVM_IMPORT_BZL = """
def _jvm_import_impl(ctx):
    jar = None
    srcjar = None
    for f in ctx.files.jars:
        if f.basename.endswith("-sources.jar"):
            srcjar = f
        else:
            jar = f
    compile_jar = ctx.actions.declare_file("%s-stamped.jar" % jar.basename[:-len(".jar")])
    ctx.actions.run(
        inputs = [jar],
        outputs = [compile_jar],
        executable = ctx.executable._singlejar,
        arguments = [
            "--sources", jar.path,
            "--output", compile_jar.path,
            "--deploy_manifest_lines", "Target-Label: %s" % str(ctx.label),
            "--normalize",
            "--exclude_build_data",
        ],
    )
    return [
        DefaultInfo(
            files = depset(direct = [jar]),
        ),
        JavaInfo(
            output_jar = jar,
            compile_jar = compile_jar,
            source_jar = srcjar,
            deps = [d[JavaInfo] for d in getattr(ctx.attr, "deps", [])],
        ),
    ]

jvm_import = rule(
    _jvm_import_impl,
    attrs = {
        "jars": attr.label_list(allow_files = [".jar"]),
        "deps": attr.label_list(providers = [JavaInfo]),
        "_singlejar": attr.label(
            executable = True,
            cfg = "host",
            default = Label("@bazel_tools//tools/jdk:singlejar"),
            allow_files = True,
        ),
    },
)
"""

def _artifact_repository_impl(ctx):
    files = []
    files += [_download_artifact(ctx, ctx.attr.sha256)]
    if ctx.attr.sha256_src:
        files += [_download_artifact(ctx, ctx.attr.sha256, classifier = "sources")]
    ctx.file("BUILD", """
filegroup(
    name = "file",
    srcs = [
        {files}
    ],
    visibility = ["//visibility:public"],
)
""".format(
        files = "\n        ".join(['"%s",' % f for f in files]),
    ))

_artifact_repository = repository_rule(
    _artifact_repository_impl,
    attrs = {
        "artifact": attr.string(mandatory = True),
        "sha256": attr.string(mandatory = True),
        "sha256_src": attr.string(),
    },
    environ = [_FETCH_SOURCES_ENV_VAR],
)

def _serialize_rule(name, **kwargs):
    lines = []
    if "replacement" in kwargs:
        lines += [
            "",
            "alias(",
            '    name = "%s",' % name,
            '    actual = "%s",' % kwargs["replacement"],
            '    visibility = ["//visibility:public"],',
            ")",
            "",
        ]
    else:
        coord = _decode_maven_coordinates(kwargs["artifact"])
        common_attrs = []
        common_attrs.append('    name = "%s",' % name)
        if kwargs.get("is_root"):
            common_attrs.append('    tags = ["maven_coordinates=%s"],' % kwargs["artifact"])
            common_attrs.append('    visibility = ["//visibility:public"],')
        else:
            common_attrs.append("    tags = [")
            common_attrs.append('        "maven_coordinates=%s",' % kwargs["artifact"])
            common_attrs.append('        "no-ide",')
            common_attrs.append("    ],")

        # handle each type of artifact appropriately
        if coord.packaging == "pom":
            lines.append("java_library(")
            lines += common_attrs
            lines.append("    exports = [%s]," % _serialize_list(kwargs.get("deps")))
            lines.append(")")
        elif coord.packaging == "aar":
            lines.append("aar_import(")
            lines += common_attrs
            lines.append('    aar = "@%s//:file",' % _artifact_repository_name(kwargs["artifact"]))
            lines.append(")")
        elif coord.packaging == "jar":
            lines.append("jvm_import(")
            lines += common_attrs
            lines.append('    jars = ["@%s//:file"],' % _artifact_repository_name(kwargs["artifact"]))
            lines.append("    deps = [%s]," % _serialize_list(kwargs.get("deps")))
            lines.append(")")
        else:
            fail("Unsupported packaging '%s' (expected 'pom', 'jar' or 'aar')" % coord.packaging, attr = "artifact")
        lines.append("")
    return lines

def _imports_repository_impl(ctx):
    ctx.file("BUILD", "")
    ctx.file("jvm_import.bzl", _JVM_IMPORT_BZL)

    # group targets by package
    targets_by_package = {}
    for label, kwargs in _DEPENDENCIES.items():
        label_parts = label.split(":", 1)
        pkg = label_parts[0][len("//"):]
        name = label_parts[1]
        if pkg not in targets_by_package:
            targets_by_package[pkg] = {}
        if name in targets_by_package[pkg]:
            fail("Duplicate targets in package (this is an implementation error)")
        targets_by_package[pkg][name] = kwargs

    # write BUILD file for each package
    for pkg, targets in targets_by_package.items():
        lines = [
            _HEADER,
            "",
            #'package(default_visibility = ["//:__subpackages__"])',
            'package(default_visibility = ["//visibility:public"])',
            "",
            'load("//:jvm_import.bzl", "jvm_import")',
            "",
        ]
        for name in sorted(targets.keys()):
            lines += _serialize_rule(name, **targets[name])
        ctx.file("%s/BUILD" % pkg, "\n".join(lines))
    return

_imports_repository = repository_rule(
    _imports_repository_impl,
)

def _download_artifact(ctx, sha256, classifier = None):
    coord = _decode_maven_coordinates(ctx.attr.artifact)
    classifier = classifier or coord.classifier or ""
    if classifier:
        classifier = "-" + classifier
    group_id = coord.group_id.replace(".", "/")
    version = coord.version
    packaging = coord.packaging
    artifact_id = coord.artifact_id
    final_name = artifact_id + "-" + version + classifier + "." + packaging
    url_suffix = group_id + "/" + artifact_id + "/" + version + "/" + final_name
    urls = []
    for server_url in _REPOSITORIES:
        if not server_url.endswith("/"):
            urls += [server_url + "/" + url_suffix]
        else:
            urls += [server_url + url_suffix]
    ctx.download(urls, output = final_name, sha256 = sha256)
    return final_name

def _decode_maven_coordinates(artifact, default_packaging = "jar"):
    parts = artifact.split(":")
    group_id = parts[0]
    artifact_id = parts[1]
    version = parts[2]
    classifier = None
    packaging = default_packaging
    if len(parts) == 4:
        packaging = parts[2]
        version = parts[3]
    elif len(parts) == 5:
        packaging = parts[2]
        classifier = parts[3]
        version = parts[4]
    return struct(
        group_id = group_id,
        artifact_id = artifact_id,
        version = version,
        classifier = classifier,
        packaging = packaging,
    )

def _artifact_repository_name(artifact):
    s = artifact.lower()
    s = s.replace(":", "_")
    s = s.replace("-", "_")
    s = s.replace(".", "_")
    return s

def _serialize_list(items):
    if not items:
        return ""
    return "\n        " + "    ".join([
        '"%s",\n    ' % i
        for i in items or []
    ])

def maven_dependencies():
    # do 'download artifact' repositories
    for label, kwargs in _DEPENDENCIES.items():
        if "sha256" in kwargs:
            _artifact_repository(
                name = _artifact_repository_name(kwargs["artifact"]),
                artifact = kwargs["artifact"],
                sha256 = kwargs["sha256"],
                sha256_src = kwargs.get("sha256_src"),
            )

    # do 'jvm_import' graph repository
    _imports_repository(
        name = "maven",  # TODO: get this from 'namePrefix' or something..
    )
